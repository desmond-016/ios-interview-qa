---
layout: default
title: 多线层
parent: iOS 相关
---

# 多线程

## 多线程的实现方式

pthread：类 Unix 系统提供的操作系统级多线程处理方式，基本用不到

NSThread：iOS 系统对 pthread 的封装，提供面向对象的操作方式，需要自己创建和开启线程

GCD：自动管理线程的生命周期，根据系统的 CPU 及其负载进行任务调度。

NSOperation、NSOperationQueue：分别对应 GCD 的任务和队列。提供了 cancel 操作和设置依赖的功能。

## 同步、异步 串行、并行

异步任务会开启新的线程，同步任务会在当前线程。异步串行多个任务会在一个开启的新线程中依次执行，异步开启并行任务会开启多个线程乱序执行。

只要是同步任务（不论是并行还是串行）都会阻塞当前线程，只要是异步任务（不管是并行还是串行）都不会阻塞当前线程。

*当在主线程同步在主队列执行任务是会死锁。*

## 实现线程同步的方法

    1. 加锁
    2. 信号量
    2. 使用串行队列

## 多线程的弊端和解决方案

    1. 占用内存，上下文需要更新寄存器等操作需要一定耗时
    2. 产生线程竞争：多个线程共享资源可能会产生与预期不同的结果
    3. 锁：为了解决线程竞争的问题需要加锁，但是加锁会有性能损失
    4. 引起 crash：多线程操作集合对象时可能引起crash，可以通过多读单写来处理（dispatch_barrier）

## 多线程锁

|  | 自旋锁 | 互斥锁 |
| --- | --- | --- |
| 概念 | 一直等待资源释放，死循环，处于忙等状态 | 当无法获取需要资源时会进入休眠状态，直到资源可用才会被唤起 |
| 优势 | 效率高，因为不会休眠，没有唤起和上下文切换的消耗 | 不需要一直占用CPU，在等待过程中 CPU 可以进行其他工作 |
| 劣势 | 一直占用 CPU， | 需要进行唤起和上下文切换 |
| 使用场景 | 被锁住的代码执行时间较长 | 被锁住的代码执行时间很短 |
| iOS 中的锁 | OSSpinLock | pthread_mutex/NSLock/NSRecursiveLock |

pthread_mutux 设置 PTHREAD_MUTEX_RECURSIVE 后就成了递归锁，NSLock 是对 pthread_mutux 普通锁的封装，NSRecusiveLock 是对 pthread_mutux 递归锁的封装。

递归锁：允许统一线程对统一把锁进行重复加锁。解决了递归调用过程中对使用同一把锁多次加锁的问题。

自旋锁可以解决优先级反转的问题。

## atomic 真的安全么？是怎么实现的？用的哪种锁？

原子性并不能保证线程安全. 只是相对运用了原子性keyword 的属性来说是线程安全的. 对于类来说则不一定.

**atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的**

比如对一个 MutableArray 设置了 atomic，只能确保多个线程在 set 和 get 这个属性的时候是线程安全的，但是如果有多个线程在同时操作这个数组（添加、删除元素），那就不是线程安全的了。

Runtime 中有一个全局数组保存了属性锁 —— 这个锁是 `spinlock_t` 的自旋锁，根据属性在实例中的位置获取到这把锁，加锁后才能操作设置或者获取值，之后再释放锁。

## performSelector:

是一个异步方法，会开启子线程

## NSThread

取消任务 `- (void)cancel` 使用自定义的变量会有问题，因为线程可见性，在一个线程修改了变量，另一个线程不一定能看到。

## 线程和队列的关系

- 线程是计算机的操作系统用来执行任务的单元
- 队列是用来存储并分发任务，队列是一种数据结构

## 信号量和互斥锁的关系

- 互斥锁用户线程的互斥，信号量用于线程的同步。互斥的访问是无序的，同步的访问是有序的，可以通过同步来实现互斥。
- 互斥锁的值只能是0/1，信号量的值可以是非负整数
- 互斥锁的加锁和解锁必须由同一线程使用，信号量可以由一个线程释放，另一个线程得到

## 线程和自动释放池

Cocoa框架的主线程在启动时会带有自动释放池，自己创建的线程需要手动添加自动释放池。

## 信号量的使用

- 创建信号量 `dispatch_semaphore_create(0)` 参数是初始化的信号数量
- 减少信号量 `dispatch_semaphore_wait(sem, 10)` 超过了设定的时间会返回非0，并**继续往下执行**，如果减一后信号量是负数就会卡死在当前线程。
- 增加信号量 `dispatch_semaphore_signal(sem)` 

## 利用信号量把多个异步操作实现串行

用 1 初始化信号量，然后在进入每个异步操作时调用 wait，完成异步操作时调用 signal

## 实现等待多个异步操作完成统一进行某操作

**信号量无法实现这个需求**，因为使用信号量没有办法控制多个异步操作的先后顺序，缺少同步机制。

需要使用 dispatch_group 来实现，可以采用 dispatch_group_leave + dispatch_group_enter + dispatch_group_notify 或者用 dispatch_group_async + dispatch_group_notify。第二种方法更方便，但是可能在某些场景下不方便使用，不如异步操作非常零散。

也可以使用 dispatch_async + dispatch_barrier_async 来实现归并多个异步操作，这里必须使用**自己创建的并发队列**。

