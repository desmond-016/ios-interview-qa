---
layout: default
title: 计算机网络
---

# 计算机网络

## HTTP

### HTTP 和 HTTPS 的区别

 - HTTP 是超文本传输协议，HTTPS 是超文本传输安全协议
 - HTTP 默认端口 80，HTTPS 默认端口 443
 - HTTP 使用明文传输，HTTPS 使用加密传输
 - HTTP 页面响应速度比 HTTPS 快
 - HTTPS 是建立在 SSL/TLS 之上的 HTTP 协议
 - HTTPS 需要先通过非对称加密得到在传输过程中使用的对称加密密钥

### HTTP2.0

HTTP/2 是对 HTTP/1 的升级，完全兼容 HTTP/1 并且在性能上有了很大的提升

http/2 升级内容：

1. 二进制分帧：在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。
2. 多路复用（multiplexing）/连接共享：http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。
3. 头部压缩
4. 请求优先级
5. 服务端推送

## TCP

### 握手

1. 客户端向服务端发送一个不包含应用数据的报文段。SYN=1 和 随机的起始序号（seq=client_isn）
2. 服务端向客户端发送一个不包含应用数据的允许连接报文段。SYN=1  ACK=client_isn+1 和随机起始序号（seq=server_isn）。服务端分配缓存和变量
3. 客户端再次确认。ACK=server_isn+1 SYN=0。客户端分配缓存和变量

### 断开

1. 客户端向服务端发送报文段，客户端进入 FIN_WAIT_1 状态。FIN=1 和一个序号 seq=x（根据上一个序号）
2. 服务端回送确认报文段，服务端进入 CLOSED_WAIT 状态，客户端收到后进入 FIN_WAIT_2 状态。ACK=1 ACKnum=x+1
3. 服务端发送终止报文段，服务端进入 LAST_ACK 状态。FIN=1 seq=y（根据上一个序号）
4. 客户端确认终止报文段，客户端进入 TIME_WAIT 状态，服务端收到后进入 CLOSED 状态，客户端等待 2MSL 后关闭连接。ACK=1 ACKnum=y+1

### 握手或者挥手次数为什么需要3次和四次，能少一次吗？

不能，需要这些次数的原因是防止报文在传递过程中出现丢包或者超时的问题。比如说在握手阶段如果没有第三个报文，那么服务端无法确认客户端是否收到了自己发送的确认报文，那就没办法确定后面到来的 TCP 报文的正确和安全性。

### TCP 和 UDP 的区别

|      | 是否有连接 | 是否可靠 | 性能 |
| ---- | ---------- | :------- | ---- |
| TCP  | 有         | 可靠     | 较差 |
| UDP  | 无         | 不可靠   | 较好 |

## SSL

### 握手

1. 客户发送它支持的密码算法列表，连同一个客户的不重数。
2. 从该列表中，服务器选择一种对称算法（如AES）、一种公钥算法（如RSA）和一种MAC算法。它把它的选择以及证书和一个服务器不重数返回给客户。
3. 客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pre-Master Secrete, PMS），用服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。
4. 使用相同的密钥导出函数，客户和服务器独立地从 PMS 和不重数中计算出主密钥（Master Secrete，MS）。然后该 MS 被切片以生成两个密码和两个 MAC 密钥。此外，当选择的对称密码应用于 CBC（例如 3DES 或 AES），则两个初始化向量（IV）也从该 MS 获得，这两个 IV 分别用于该连接的两端。自此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用 MAC）。
5. 客户发送所有握手报文的一个 MAC。
6. 服务器发送所有握手报文的一个 MAC。

> 最后两步使握手免遭篡改。

### 断开

通过终止 TCP 连接来结束 SSL 会话。为了防止被截断攻击就在类型字段中指出该记录是用于终止 SSL 会话的。接收方通过使用的 MAC 就可以得知是否是一个正常的关闭。

## WebSocket

> 下面内容主要参考自 [WebSocket协议（一）- 简介以及连接建立过程](https://www.timefly.cn/learn-websocket-protocol-1/)

### 什么是WebSocket

WebSocket 是 HTML5 中提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 经过一次握手就可以建立全双工通讯。

### Websocket 和 HTTP 的关系

WebSocket 和 HTTP 都是建立在 TCP 之上的应用层协议，它不是 HTTP 的增强。

在建立连接的过程中，WebSocket 和 HTTP 有相似之处，下面详细说。

### WebSocket 建立连接的过程

首先要建立 TCP 连接，之后建立 WebSocket 连接。

1. 客户端向服务端发送一个握手包，这个握手包的格式必须符合 HTTP 报文格式的规范。其中：
    - 方法必须为 GET 方法
    - HTTP 版本不能低于 1.1
    - 必须包含 Upgrade 头部，值必须为 websocket
    - 必须包含Sec-WebSocket-Key头部，值是一个Base64编码的16字节随机字符串。
    - 必须包含Sec-WebSocket-Version头部，值必须为13
2. 服务端验证客户端的握手包符合规范之后会向客户端发送一个握手包。其中：
    - 必须包含Connection头部，值必须为Upgrade
    - 须包含一个Upgrade头部，值必须为websocket
    - 必须包含一个Sec-Websocket-Accept头部，值是根据如下规则计算的：
        - 首先将一个固定的字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接到Sec-WebSocket-Key对应值的后面。
        - 对拼接后的字符串进行一次SHA-1计算
        - 将计算结果进行Base-64编码
3. 客户端收到服务端的握手包之后，验证报文格式时候符合规范，以2）中同样的方式计算Sec-WebSocket-Accept并与服务端握手包里的值进行比对。

当连接建立完成后，WebSocket 就和 HTTP 没有什么关系了。
